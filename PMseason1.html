<script>
(() => {
  // =========================================================
  // Daily Mode (Deterministic Seed + Modifiers + Random Event)
  // =========================================================
  const qs = new URLSearchParams(location.search);
  const RUN_MODE = (qs.get("mode") || "normal").toLowerCase(); // normal | daily
  const CUSTOM_SEED = qs.get("seed"); // optional override for testing/sharing
  const RUN_TZ = qs.get("tz") || "Asia/Kuala_Lumpur";
  const RUN_KEY = "PMseason1";

  function hashStringFNV1a(str) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0);
  }
  function mulberry32(seed) {
    let a = seed >>> 0;
    return function () {
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function ymdInTimeZone(timeZone) {
    // stable YYYY-MM-DD using formatToParts
    const parts = new Intl.DateTimeFormat("en-CA", {
      timeZone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(new Date());
    const m = {};
    for (const p of parts) if (p.type !== "literal") m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day}`;
  }
  function seedForToday({ timeZone, seedKey }) {
    return `${seedKey}|${ymdInTimeZone(timeZone)}`;
  }
  function clampPercent01(x) {
    return Math.max(0, Math.min(1, x));
  }
  function setByPath(obj, path, value) {
    const parts = path.split(".");
    let cur = obj;
    for (let i = 0; i < parts.length - 1; i++) cur = cur[parts[i]];
    cur[parts[parts.length - 1]] = value;
  }
  function getByPath(obj, path) {
    const parts = path.split(".");
    let cur = obj;
    for (const p of parts) cur = cur?.[p];
    return cur;
  }

  // Configure daily modifiers here (ranges => "unlimited variability")
  // These apply ONCE at run start (deterministic for the day/seed).
  const DAILY_MODIFIERS = [
    { id: "dm", label: "DM/unit", path: "dmUnit", kind: "add", min: -1.2, max: 1.2, round: 2 },
    { id: "dl", label: "DL/unit", path: "dlUnit", kind: "add", min: -1.0, max: 1.0, round: 2 },
    { id: "voh", label: "Var FOH/unit", path: "vohUnit", kind: "add", min: -0.8, max: 0.8, round: 2 },
    { id: "ffoh", label: "Fixed FOH/episode", path: "fixedFOH", kind: "add", min: -500, max: 500, round: 0 },
    { id: "cap", label: "Capacity", path: "baseCap", kind: "add", min: -15, max: 15, round: 0 },

    // Keep these small so daily mode remains fair
    { id: "scrap", label: "Starting scrap", path: "scrapRate", kind: "add", min: -0.002, max: 0.002, round: 4 },
    { id: "qrisk", label: "Starting quality risk", path: "qualityRisk", kind: "add", min: -0.2, max: 0.2, round: 0 }
  ];

  // Daily event catalog (easy to expand)
  const DAILY_EVENTS = [
    {
      id: "quality_upgrade",
      label: "Quality upgrade program",
      notes: ["Quality upgrade reduces scrap and risk."],
      effects: [
        { path: "scrapRate", op: "add", value: -0.005 },
        { path: "qualityRisk", op: "add", value: -1 }
      ]
    },
    {
      id: "supplier_delay",
      label: "Supplier delay & rush freight",
      notes: ["Rush freight increases overhead this run."],
      effects: [
        { path: "fixedFOH", op: "add", value: 600 } // safer than totalCOP direct
      ]
    },
    {
      id: "minor_breakdown",
      label: "Minor machine breakdown",
      notes: ["Breakdown increases scrap for this run."],
      effects: [
        { path: "scrapRate", op: "add", value: 0.004 }
      ]
    }
  ];

  function applyModifierOnce(state, rng, m) {
    const before = Number(getByPath(state, m.path) ?? 0);
    const r = m.min + rng() * (m.max - m.min);

    let after = before;
    if (m.kind === "add") after = before + r;
    else if (m.kind === "mult") after = before * r;

    if (typeof m.round === "number") {
      const p = Math.pow(10, m.round);
      after = Math.round(after * p) / p;
    }

    setByPath(state, m.path, after);

    const delta = after - before;
    const sign = delta >= 0 ? "+" : "";
    return `${m.label}: ${before} → ${after} (${sign}${(Math.round(delta * 10000) / 10000)})`;
  }

  function applyEventEffects(state, evt) {
    const notes = [];
    for (const e of (evt.effects ?? [])) {
      const before = Number(getByPath(state, e.path) ?? 0);
      let after = before;

      if (e.op === "add") after = before + Number(e.value ?? 0);
      else if (e.op === "mult") after = before * Number(e.value ?? 1);
      else if (e.op === "set") after = Number(e.value ?? 0);

      setByPath(state, e.path, after);
      const d = after - before;
      const sign = d >= 0 ? "+" : "";
      notes.push(`Event effect: ${e.path} ${before} → ${after} (${sign}${(Math.round(d * 10000) / 10000)})`);
    }
    return notes;
  }

  function pickOneEventDeterministic(seed) {
    const rng = mulberry32(hashStringFNV1a(seed + "|event"));
    const idx = Math.floor(rng() * DAILY_EVENTS.length);
    return DAILY_EVENTS[idx];
  }

  function clampStateSanity(s) {
    if (typeof s.scrapRate === "number") s.scrapRate = clampPercent01(s.scrapRate);
    if (typeof s.qualityRisk === "number") s.qualityRisk = Math.max(0, Math.round(s.qualityRisk));
    if (typeof s.totalCOP === "number") s.totalCOP = Math.max(0, Math.round(s.totalCOP));

    // prevent negative cost rates
    if (typeof s.dmUnit === "number") s.dmUnit = Math.max(0, s.dmUnit);
    if (typeof s.dlUnit === "number") s.dlUnit = Math.max(0, s.dlUnit);
    if (typeof s.deUnit === "number") s.deUnit = Math.max(0, s.deUnit);
    if (typeof s.vohUnit === "number") s.vohUnit = Math.max(0, s.vohUnit);
    if (typeof s.fixedFOH === "number") s.fixedFOH = Math.max(0, Math.round(s.fixedFOH));
    if (typeof s.baseCap === "number") s.baseCap = Math.max(0, Math.round(s.baseCap));
  }

  // This holds daily run info to display (seed/modifiers/event)
  let runMeta = {
    mode: RUN_MODE,
    seed: null,
    tz: RUN_TZ,
    modifierNotes: [],
    event: null,
    eventNotes: [],
    eventEffectNotes: []
  };

  function initRunMetaAndApplyToState(state) {
    runMeta = {
      mode: RUN_MODE,
      seed: null,
      tz: RUN_TZ,
      modifierNotes: [],
      event: null,
      eventNotes: [],
      eventEffectNotes: []
    };

    if (RUN_MODE !== "daily") return;

    const seed = CUSTOM_SEED || seedForToday({ timeZone: RUN_TZ, seedKey: RUN_KEY });
    runMeta.seed = seed;

    // modifiers
    const rngMods = mulberry32(hashStringFNV1a(seed + "|mods"));
    for (const m of DAILY_MODIFIERS) {
      runMeta.modifierNotes.push(applyModifierOnce(state, rngMods, m));
    }

    // event
    const evt = pickOneEventDeterministic(seed);
    runMeta.event = evt;
    runMeta.eventNotes = (evt.notes ?? []).slice();
    runMeta.eventEffectNotes = applyEventEffects(state, evt);

    clampStateSanity(state);
  }

  function updateRunModeUI() {
    const el = document.getElementById("runModeText");
    if (!el) return;

    // Build links without breaking other query params
    const uBase = new URL(location.href);

    // Normal link removes mode/seed/tz
    const uNormal = new URL(uBase.toString());
    uNormal.searchParams.delete("mode");
    uNormal.searchParams.delete("seed");
    uNormal.searchParams.delete("tz");

    // Daily link sets mode=daily, removes seed unless you want to lock it
    const uDaily = new URL(uBase.toString());
    uDaily.searchParams.set("mode", "daily");
    uDaily.searchParams.delete("seed"); // daily auto-seed by day unless you pass seed manually

    const normalA = document.getElementById("normalModeLink");
    const dailyA = document.getElementById("dailyModeLink");
    if (normalA) normalA.href = uNormal.pathname + (uNormal.search ? uNormal.search : "");
    if (dailyA) dailyA.href = uDaily.pathname + (uDaily.search ? uDaily.search : "");

    if (runMeta.mode !== "daily") {
      el.innerHTML = `
        <div><b>Normal</b> — standard run (no daily modifiers).</div>
        <div class="small muted">Tip: click <b>Today’s Run</b> for a deterministic daily variation.</div>
      `;
      return;
    }

    const modsHtml = runMeta.modifierNotes.slice(0, 6).map(x => `• ${escapeHtml(x)}`).join("<br/>");
    const evtTitle = runMeta.event ? escapeHtml(runMeta.event.label) : "—";
    const evtNotes = (runMeta.eventNotes ?? []).map(n => `• ${escapeHtml(n)}`).join("<br/>");

    el.innerHTML = `
      <div><b>Daily</b> — deterministic variation for the day.</div>
      <div class="mono small">Timezone: ${escapeHtml(runMeta.tz)} | Seed: ${escapeHtml(runMeta.seed || "")}</div>
      <div class="hr"></div>
      <div class="small muted"><b>Daily modifiers</b></div>
      <div class="small mono">${modsHtml || "<span class='muted'>No modifiers</span>"}</div>
      <div class="hr"></div>
      <div class="small muted"><b>Daily event</b></div>
      <div class="small mono">• ${evtTitle}</div>
      <div class="small mono">${evtNotes || ""}</div>
    `;
  }

  // ---------- Constants ----------
  const BEST_COP = 183538;

  const GAME_BASE_URL = `${location.origin}${location.pathname}`;
  const UTM = "utm_source=game_share&utm_medium=share_button&utm_campaign=PMseason1";

  function buildShareUrl() {
    const u = new URL(GAME_BASE_URL);
    const p = new URLSearchParams();
    // keep UTM
    UTM.split("&").forEach(kv => {
      const [k, v] = kv.split("=");
      p.set(k, v);
    });

    // share daily mode as-is (optional)
    if (runMeta.mode === "daily") {
      p.set("mode", "daily");
      // lock to the same seed so friends see the exact same daily run
      if (runMeta.seed) p.set("seed", runMeta.seed);
      if (runMeta.tz) p.set("tz", runMeta.tz);
    }
    u.search = p.toString();
    return u.toString();
  }

  const EP_GUIDES = {
    1: "https://accountingaventure.wordpress.com/episode-1-set-up-your-factory-fixed-costs-vs-capacity/",
    2: "https://accountingaventure.wordpress.com/episode-2-materials-sourcing-unit-cost-vs-hidden-waste/",
    3: "https://accountingaventure.wordpress.com/episode-3-ramp-up-decision-incremental-cost-vs-future-rework/",
    4: "https://accountingaventure.wordpress.com/episode-4-quality-control-vs-cost-cutting-visible-cost-vs-hidden-cost/",
    5: "https://accountingaventure.wordpress.com/episode-5-maintenance-the-sunk-cost-trap-relevant-vs-irrelevant/",
    6: "https://accountingaventure.wordpress.com/episode-6-locked-orders-capacity-scrap-can-break-you/",
    7: "https://accountingaventure.wordpress.com/episode-7-complaints-response-spend-smart-not-big/",
    8: "https://accountingaventure.wordpress.com/episode-8-finale-finish-strong-without-risk-spikes/"
  };

  // ---------- Utilities ----------
  const fmt = (n) => (Math.round(n * 100) / 100).toLocaleString(undefined, {maximumFractionDigits: 2});
  const ceil = (n) => Math.ceil(n);
  const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
  const $ = (id) => document.getElementById(id);

  function toast(msg) {
    const t = $("toast");
    t.textContent = msg;
    t.classList.add("show");
    setTimeout(() => t.classList.remove("show"), 1600);
  }

  // ---------- Season Settings ----------
  const targets = [0, 0, 220, 260, 280, 300, 320, 320, 340]; // index by episode
  const reasons = [
    "",
    "Start here.",
    "Pilot order.",
    "Forecast raised after pilot success.",
    "New customer trial order.",
    "Peak demand week.",
    "Orders locked (penalties if short).",
    "Repeat order (customer scrutiny).",
    "Final rush shipment."
  ];

  // ---------- Base State ----------
  const BASE_STATE = {
    ep: 1,
    totalCOP: 0,

    // cost rates
    dmUnit: 30,
    dlUnit: 18,
    deUnit: 4,
    vohUnit: 10,
    fixedFOH: 9000,

    // capacity
    baseCap: 380,

    // risk + scrap (burst thresholds)
    scrapRate: 0.00,
    qualityRisk: 0,
    complaintFlag: false,

    // flags
    choseCheapSupplier: false,
    vohAdjActive: false,
    dmAdjActive: false,
    dlAdjActive: false,

    // last SOC record should persist across episodes
    lastRecord: null
  };

  // ---------- Game State ----------
  let state;

  function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function resetState() {
    state = deepCopy(BASE_STATE);
    initRunMetaAndApplyToState(state);
    updateRunModeUI();
  }

  // ---------- Episodes ----------
  const episodes = [
    null,
    {
      title: "Episode 1 — Set up your factory",
      story:
        "You choose your facility. Finance wants low fixed costs, but Operations warns fragile setups cause problems later. " +
        "This locks your fixed factory overhead and season capacity.",
      options: [
        { key: "A", text: "Deposit 5,000; Fixed FOH 9,000/episode; Capacity 380." },
        { key: "B", text: "Deposit 2,000; Fixed FOH 6,000/episode; Capacity 330." },
        { key: "C", text: "Deposit 10,000; Fixed FOH 12,000/episode; Capacity 450." }
      ]
    },
    {
      title: "Episode 2 — Materials sourcing (pilot order)",
      story:
        "A pilot run tests supplier quality. Cheaper materials can look good in COP but increase scrap and complaints later. " +
        "Choose how you source Direct Materials.",
      options: [
        { key: "A", text: "Standard supplier: DM 30/unit; extra cost 0." },
        { key: "B", text: "Bulk discount: handling/storage 8,000; DM becomes 28/unit from now on." },
        { key: "C", text: "Cheapest supplier: DM becomes 26/unit from now on (riskier)." }
      ]
    },
    {
      title: "Episode 3 — Ramp-up decision (forecast increases)",
      story:
        "The forecast rises after pilot success. You can invest in training, push overtime, or do nothing and accept rising waste later. " +
        "This is about incremental cost vs future rework/scrap.",
      options: [
        { key: "A", text: "Training: pay 3,000 now (reduce rework later)." },
        { key: "B", text: "Overtime: DL +5/unit this episode only." },
        { key: "C", text: "Do nothing: pay 0 now (hidden wastage later)." }
      ]
    },
    {
      title: "Episode 4 — Quality control vs “cost cutting”",
      story:
        "A trial order includes strict inspection. Cutting inspection can reduce FOH now, but raises quality and scrap risk. " +
        "Choose how you handle QC.",
      options: [
        { key: "A", text: "Keep inspection: FOH +1,500 this episode." },
        { key: "B", text: "Reduce inspection: FOH -1,000 this episode (riskier)." },
        { key: "C", text: "Process workshop: pay 2,500 now (improve materials later)." }
      ]
    },
    {
      title: "Episode 5 — Maintenance and the sunk cost trap",
      story:
        "Someone mentions last quarter’s 7,000 equipment study (sunk cost). Ignore it. Today’s relevant decision is maintenance vs running hot. " +
        "This affects waste later.",
      options: [
        { key: "A", text: "Preventive maintenance: pay 2,000 now." },
        { key: "B", text: "Skip maintenance: pay 0 now (risk later)." },
        { key: "C", text: "Replace worn part only: pay 1,200 now." }
      ]
    },
    {
      title: "Episode 6 — Locked orders (output must hit)",
      story:
        "Orders are locked. Scrap can now cause missed targets. Cutting spec may reduce cost now but trigger complaints. " +
        "You must deliver the target output.",
      options: [
        { key: "A", text: "Standard spec: no changes." },
        { key: "B", text: "Cost-cut spec: DM -3/unit this episode only (riskier)." },
        { key: "C", text: "Line balancing: pay 1,800 now; DL -2/unit in Ep7–Ep8." }
      ]
    },
    {
      title: "Episode 7 — Response to early complaints / instability",
      story:
        "Customer feedback is coming in. You can pay for containment, ignore it, or audit suppliers. " +
        "This is about relevant incremental cost to avoid bigger failures.",
      options: [
        { key: "A", text: "Containment & sorting: pay 2,400 now." },
        { key: "B", text: "Continue as-is: pay 0 now." },
        { key: "C", text: "Supplier audit: pay 3,500 now (most useful if supplier quality is the root cause)." }
      ]
    },
    {
      title: "Episode 8 — Finale (reputation test)",
      story:
        "Final shipment window. Management judges your COP and whether you met output without complaints exploding. " +
        "Low COP is meaningless if the customer churns.",
      options: [
        { key: "A", text: "Final quality push: FOH +3,000 this episode." },
        { key: "B", text: "“Numbers look good” push: FOH -1,500 this episode (riskier)." },
        { key: "C", text: "Rework sprint: DL +4/unit this episode (stabilize quality)." }
      ]
    }
  ];

  // ---------- Derived Adjustments ----------
  function currentDmUnit(ep, optKey=null) {
    let dm = state.dmUnit;
    if (state.dmAdjActive && ep >= 6) dm -= 2;
    if (ep === 6 && optKey === "B") dm -= 3;
    return Math.max(0, dm);
  }
  function currentDlUnit(ep, optKey=null) {
    let dl = state.dlUnit;
    if (ep === 3 && optKey === "B") dl += 5;
    if (state.dlAdjActive && ep >= 7) dl -= 2;
    if (ep === 8 && optKey === "C") dl += 4;
    return Math.max(0, dl);
  }
  function currentVohUnit(ep) {
    let voh = state.vohUnit;
    if (state.vohAdjActive && ep >= 5) voh -= 2;
    return Math.max(0, voh);
  }
  function effectiveCapacity() { return state.baseCap; }
  function neededProduction(target, scrapRate) {
    const sr = clamp(scrapRate, 0, 0.30);
    const pu = (target <= 0) ? 0 : ceil(target / (1 - sr));
    const extra = Math.max(0, pu - target);
    return { pu, extra, sr };
  }

  // ---------- SOC Calculation ----------
  function computeSOC(ep, optKey) {
    const target = targets[ep];
    const cap = effectiveCapacity();
    const { pu, extra, sr } = neededProduction(target, state.scrapRate);

    let fohOneOff = 0;
    if (ep === 2 && optKey === "B") fohOneOff += 8000;
    if (ep === 3 && optKey === "A") fohOneOff += 3000;
    if (ep === 4 && optKey === "A") fohOneOff += 1500;
    if (ep === 4 && optKey === "B") fohOneOff -= 1000;
    if (ep === 4 && optKey === "C") fohOneOff += 2500;
    if (ep === 5 && optKey === "A") fohOneOff += 2000;
    if (ep === 5 && optKey === "C") fohOneOff += 1200;
    if (ep === 6 && optKey === "C") fohOneOff += 1800;
    if (ep === 7 && optKey === "A") fohOneOff += 2400;
    if (ep === 7 && optKey === "C") fohOneOff += 3500;
    if (ep === 8 && optKey === "A") fohOneOff += 3000;
    if (ep === 8 && optKey === "B") fohOneOff -= 1500;

    const dmU = currentDmUnit(ep, optKey);
    const dlU = currentDlUnit(ep, optKey);
    const deU = state.deUnit;
    const vohU = currentVohUnit(ep);

    const DM = pu * dmU;
    const DL = pu * dlU;
    const DE = pu * deU;
    const prime = DM + DL + DE;

    const FOH = (ep >= 2 ? state.fixedFOH : 0) + (pu * vohU) + fohOneOff;
    const COP = prime + FOH;

    const achievedTarget = (pu <= cap);

    return {
      ep, target, cap,
      scrapRate: sr,
      pu, extra, achievedTarget,
      dmU, dlU, deU, vohU,
      fixedFOH: (ep >= 2 ? state.fixedFOH : 0),
      fohOneOff,
      DM, DL, DE, prime, FOH, COP
    };
  }

  // ---------- Apply Choice Effects ----------
  function applyChoiceEffects(ep, optKey, notes) {
    if (ep === 1) {
      if (optKey === "A") {
        state.fixedFOH = 9000; state.baseCap = 380;
        notes.push("Setup chosen: Fixed FOH set to 9,000/episode. Capacity set to 380.");
      } else if (optKey === "B") {
        state.fixedFOH = 6000; state.baseCap = 330;
        notes.push("Setup chosen: Fixed FOH set to 6,000/episode. Capacity set to 330 (tighter).");
      } else {
        state.fixedFOH = 12000; state.baseCap = 450;
        notes.push("Setup chosen: Fixed FOH set to 12,000/episode. Capacity set to 450 (strong).");
      }
      return;
    }

    if (ep === 2) {
      if (optKey === "A") {
        state.dmUnit = 30;
        notes.push("DM stays 30/unit (stable quality baseline).");
      } else if (optKey === "B") {
        state.dmUnit = 28;
        notes.push("Bulk discount: DM becomes 28/unit from now on. Handling/storage is counted in this episode’s overheads.");
      } else {
        state.dmUnit = 26;
        state.scrapRate += 0.01;
        state.qualityRisk += 1;
        state.complaintFlag = true;
        state.choseCheapSupplier = true;
        notes.push("Cheapest supplier: DM becomes 26/unit. Scrap +1% and Quality risk +1 (higher complaint chance).");
      }
      return;
    }

    if (ep === 3) {
      if (optKey === "A") {
        state.vohAdjActive = true;
        notes.push("Training: adds cost now, but reduces future rework overheads (Ep5–Ep8).");
      } else if (optKey === "B") {
        notes.push("Overtime: higher labour cost this episode only.");
      } else {
        state.scrapRate += 0.03;
        notes.push("Do nothing: scrap jumps up (waste increases).");
      }
      return;
    }

    if (ep === 4) {
      if (optKey === "A") {
        notes.push("Keep inspection: prevention cost this episode; helps avoid complaints.");
      } else if (optKey === "B") {
        state.qualityRisk += 1;
        state.scrapRate += 0.01;
        state.complaintFlag = true;
        notes.push("Reduce inspection: cost looks lower now, but complaints and waste risk increase.");
      } else {
        state.dmAdjActive = true;
        notes.push("Process workshop: cost now, but improves material usage later (Ep6–Ep8).");
      }
      return;
    }

    if (ep === 5) {
      notes.push("Reminder: last quarter’s 7,000 equipment study is a SUNK cost (irrelevant today).");
      if (optKey === "A") {
        state.scrapRate -= 0.02;
        notes.push("Preventive maintenance: reduces waste (scrap improves).");
      } else if (optKey === "B") {
        state.qualityRisk += 1;
        state.complaintFlag = true;
        notes.push("Skip maintenance: saves money now, but complaints risk increases.");
      } else {
        notes.push("Replace part: improves reliability, but doesn’t reduce waste much.");
      }
      state.scrapRate = clamp(state.scrapRate, 0, 0.30);
      return;
    }

    if (ep === 6) {
      if (optKey === "A") {
        notes.push("Standard spec: stable path.");
      } else if (optKey === "B") {
        state.qualityRisk += 1;
        state.complaintFlag = true;
        state.scrapRate += 0.02;
        notes.push("Cost-cut spec: lower material cost now, but complaints and waste increase.");
      } else {
        state.dlAdjActive = true;
        notes.push("Line balancing: cost now, but labour becomes more efficient later (Ep7–Ep8).");
      }
      state.scrapRate = clamp(state.scrapRate, 0, 0.30);
      return;
    }

    if (ep === 7) {
      if (optKey === "A") {
        state.qualityRisk = Math.max(0, state.qualityRisk - 1);
        state.scrapRate = Math.max(0, state.scrapRate - 0.01);
        notes.push("Containment: reduces complaints and waste immediately.");
      } else if (optKey === "B") {
        notes.push("Continue as-is: no immediate cost. Risk remains.");
      } else {
        if (state.choseCheapSupplier) {
          state.qualityRisk = Math.max(0, state.qualityRisk - 1);
          state.scrapRate = Math.max(0, state.scrapRate - 0.005);
          notes.push("Supplier audit: useful because supplier quality was a known risk earlier.");
        } else {
          notes.push("Supplier audit: may have limited benefit if supplier quality was not the root cause.");
        }
      }
      state.scrapRate = clamp(state.scrapRate, 0, 0.30);
      return;
    }

    if (ep === 8) {
      if (optKey === "A") {
        if (state.qualityRisk > 0) state.qualityRisk = Math.max(0, state.qualityRisk - 1);
        notes.push("Final quality push: reduces complaint risk, but costs more this episode.");
      } else if (optKey === "B") {
        state.qualityRisk += 1;
        state.scrapRate += 0.01;
        state.complaintFlag = true;
        notes.push("Numbers-first: cost looks lower, but complaints and waste risk increase.");
      } else {
        if (state.qualityRisk > 0) state.qualityRisk = Math.max(0, state.qualityRisk - 1);
        notes.push("Rework sprint: stabilizes quality, but labour cost rises this episode.");
      }
      state.scrapRate = clamp(state.scrapRate, 0, 0.30);
      return;
    }
  }

  // ---------- Burst Rules (Immediate after choice) ----------
  function immediateBurstCheck() {
    if (state.scrapRate >= 0.03) {
      return { burst: true, reason: `Waste out of control: scrap reached ${fmt(state.scrapRate * 100)}% (threshold ≥ 3%).` };
    }
    if (state.qualityRisk >= 3) {
      return { burst: true, reason: `Customer complaints exploded: quality risk = ${state.qualityRisk} (threshold ≥ 3).` };
    }
    return { burst: false, reason: "" };
  }
  function outputBurstCheck(rec) {
    if (!rec.achievedTarget) {
      return { burst: true, reason: `Failed output target: needed production ${rec.pu} units exceeds capacity ${rec.cap}.` };
    }
    return { burst: false, reason: "" };
  }

  // ---------- Main Step ----------
  function chooseOption(ep, optKey) {
    [...$("choiceButtons").querySelectorAll("button")].forEach(b => b.disabled = true);

    $("revealBox").classList.add("hidden");
    $("gameOverBox").classList.add("hidden");
    $("seasonCompleteBox").classList.add("hidden");

    const notes = [];
    applyChoiceEffects(ep, optKey, notes);

    const imm = immediateBurstCheck();

    const rec = computeSOC(ep, optKey);
    state.lastRecord = rec;

    if (ep >= 2) state.totalCOP += rec.COP;

    updateRightPanel();

    if (imm.burst) return endGameOver(imm.reason);

    const out = outputBurstCheck(rec);
    if (out.burst) return endGameOver(out.reason);

    if (ep === 8) return endSeasonComplete();

    showReveal(notes, rec);
  }

  // ---------- UI Rendering ----------
  function showPreEpisode() {
    $("preEpisode").classList.remove("hidden");
    $("episodeScreen").classList.add("hidden");
    updateRunModeUI();
    updateRightPanel();
  }

  function showEpisodeScreen() {
    $("preEpisode").classList.add("hidden");
    $("episodeScreen").classList.remove("hidden");
    renderEpisode();
  }

  function renderEpisode() {
    const ep = state.ep;

    $("epTitle").textContent = episodes[ep].title;
    $("story").textContent = episodes[ep].story;

    $("epGuideBtn").href = EP_GUIDES[ep] || EP_GUIDES[1];

    const pills = [];
    pills.push(`<div class="pill">Episode ${ep} of 8</div>`);
    pills.push(`<div class="pill">${escapeHtml(reasons[ep])}</div>`);
    $("epMetaPills").innerHTML = pills.join("");

    const btns = $("choiceButtons");
    btns.innerHTML = "";
    episodes[ep].options.forEach(opt => {
      const b = document.createElement("button");
      b.textContent = `Option ${opt.key}: ${opt.text}`;
      b.onclick = () => chooseOption(ep, opt.key);
      btns.appendChild(b);
    });

    $("revealBox").classList.add("hidden");
    $("gameOverBox").classList.add("hidden");
    $("seasonCompleteBox").classList.add("hidden");

    renderSocTable(state.lastRecord);
    updateRightPanel();
  }

  function updateRightPanel() {
    $("totalCop").textContent = fmt(state.totalCOP);
    $("qRisk").textContent = `${state.qualityRisk}${state.complaintFlag ? " (watch complaints)" : ""}`;
    $("scrap").textContent = `${fmt(state.scrapRate * 100)}%`;

    const ep = state.ep;
    const target = targets[ep];
    const cap = effectiveCapacity();
    const need = neededProduction(target, state.scrapRate);

    const statusBits = [];
    statusBits.push(`Target: ${fmt(target)} good units`);
    statusBits.push(`Needed production units: ${fmt(need.pu)}${need.extra > 0 ? ` (extra ${fmt(need.extra)} due to waste)` : ""}`);
    statusBits.push(`Capacity: ${fmt(cap)}`);
    if (ep >= 2) statusBits.push(need.pu <= cap ? "Status: OK (based on current scrap)" : "Status: AT RISK (current scrap may break output)");
    statusBits.push(`Burst thresholds: scrap ≥ 3% OR quality risk ≥ 3.`);

    $("statusLine").innerHTML = statusBits.map(x => `• ${escapeHtml(x)}`).join("<br/>");

    $("socLabel").textContent = state.lastRecord ? `Last episode result (Ep ${state.lastRecord.ep})` : "No result yet";

    const lines = [];
    lines.push(`DM/unit: ${fmt(state.dmUnit)}${state.dmAdjActive ? " (workshop improves Ep6–8)" : ""}`);
    lines.push(`DL/unit: ${fmt(state.dlUnit)}${state.dlAdjActive ? " (line balancing improves Ep7–8)" : ""}`);
    lines.push(`DE/unit: ${fmt(state.deUnit)}`);
    lines.push(`Var FOH/unit: ${fmt(state.vohUnit)}${state.vohAdjActive ? " (training improves Ep5–8)" : ""}`);
    lines.push(`Fixed FOH/episode: ${fmt(state.fixedFOH)}`);
    lines.push(`Capacity: ${fmt(state.baseCap)}`);
    $("costModelBox").innerHTML = lines.map(x => escapeHtml(x)).join("<br/>");
  }

  function showReveal(notes, rec) {
    const lines = [];

    // Prepend daily info (seed/modifiers/event label+notes)
    if (runMeta.mode === "daily") {
      lines.push(`• Run mode: DAILY (Seed: ${runMeta.seed || ""}, TZ: ${runMeta.tz})`);
      if (runMeta.event?.label) lines.push(`• Daily event: ${runMeta.event.label}`);
      (runMeta.eventNotes || []).forEach(n => lines.push(`• Event note: ${n}`));
      lines.push(`• (Daily modifiers applied at run start — see Run mode box on the start screen.)`);
      lines.push("• —");
    }

    notes.forEach(n => lines.push(`• ${n}`));

    if (rec.ep >= 2) {
      if (rec.extra > 0) {
        lines.push(`• Waste effect: to deliver ${rec.target} good units with ${fmt(rec.scrapRate*100)}% scrap, you produced ${rec.extra} extra units (total ${rec.pu}).`);
      } else {
        lines.push(`• Waste effect: scrap is ${fmt(rec.scrapRate*100)}%, so you produced exactly ${rec.pu} units to meet the target.`);
      }
      lines.push(`• Output check: ✅ target met.`);
      lines.push(`• This episode COP = ${fmt(rec.COP)}. Total COP so far = ${fmt(state.totalCOP)}.`);
      lines.push(`• Quality risk now = ${state.qualityRisk}. Scrap now = ${fmt(state.scrapRate*100)}%.`);
    } else {
      lines.push("• Setup week: no production yet.");
    }

    $("revealText").innerHTML = lines.map(x => `<div>${escapeHtml(x)}</div>`).join("");

    renderSocTable(rec);
    updateRightPanel();

    $("revealBox").classList.remove("hidden");

    $("nextBtn").onclick = () => {
      if (state.ep < 8) { state.ep += 1; renderEpisode(); }
    };
    $("restartBtn").onclick = () => { resetState(); showPreEpisode(); };
  }

  // ---------- SOC Table ----------
  function renderSocTable(rec) {
    const t = $("socTable");
    if (!rec || rec.ep === 1) {
      t.innerHTML = `
        <thead><tr><th>Particulars</th><th>Amount</th></tr></thead>
        <tbody>
          <tr><td class="muted">No episode result yet</td><td class="muted">—</td></tr>
        </tbody>
      `;
      return;
    }

    const commonTop = `
      <div>Target: ${fmt(rec.target)} good units</div>
      <div>Scrap: ${fmt(rec.scrapRate*100)}% → extra produced: ${fmt(rec.extra)} units</div>
      <div>Total produced: ${fmt(rec.pu)} units</div>
    `;

    const advPU = `
      <details>
        <summary>Advanced details</summary>
        <div class="muted" style="margin-top:6px;">
          Game calculation (not a syllabus formula): needed production is computed from target and scrap rate.
        </div>
      </details>
    `;

    const rows = [];
    function addRow(label, amount, workHtml) {
      const id = `work_${label.replace(/\W+/g,'_')}_${rec.ep}`;
      rows.push(`
        <tr class="clickable" data-work="${id}">
          <td><span class="caret">▶</span>${escapeHtml(label)}</td>
          <td>${fmt(amount)}</td>
        </tr>
        <tr class="workrow hidden" id="${id}">
          <td colspan="2"><div class="workbox small mono">${workHtml}</div></td>
        </tr>
      `);
    }

    addRow("Direct Materials", rec.DM, `
      ${commonTop}
      <div>DM/unit: ${fmt(rec.dmU)}</div>
      <div>DM cost = ${fmt(rec.pu)} × ${fmt(rec.dmU)} = ${fmt(rec.DM)}</div>
      ${advPU}
    `);

    addRow("Direct Labour", rec.DL, `
      ${commonTop}
      <div>DL/unit: ${fmt(rec.dlU)}</div>
      <div>DL cost = ${fmt(rec.pu)} × ${fmt(rec.dlU)} = ${fmt(rec.DL)}</div>
      ${advPU}
    `);

    addRow("Direct Expenses", rec.DE, `
      ${commonTop}
      <div>DE/unit: ${fmt(rec.deU)}</div>
      <div>DE cost = ${fmt(rec.pu)} × ${fmt(rec.deU)} = ${fmt(rec.DE)}</div>
      ${advPU}
    `);

    addRow("Prime Cost", rec.prime, `
      <div>Prime Cost = DM + DL + DE</div>
      <div>= ${fmt(rec.DM)} + ${fmt(rec.DL)} + ${fmt(rec.DE)} = ${fmt(rec.prime)}</div>
    `);

    addRow("Factory Overheads", rec.FOH, `
      ${commonTop}
      <div>Fixed FOH (this episode): ${fmt(rec.fixedFOH)}</div>
      <div>Variable FOH/unit: ${fmt(rec.vohU)}</div>
      <div>Variable FOH = ${fmt(rec.pu)} × ${fmt(rec.vohU)} = ${fmt(rec.pu * rec.vohU)}</div>
      <div>One-off overheads (this episode): ${fmt(rec.fohOneOff)}</div>
      <div>Factory Overheads = ${fmt(rec.fixedFOH)} + ${fmt(rec.pu * rec.vohU)} + ${fmt(rec.fohOneOff)} = ${fmt(rec.FOH)}</div>
      <details>
        <summary>Advanced details</summary>
        <div class="muted" style="margin-top:6px;">
          One-off overheads reflect the specific decision you selected for that episode.
        </div>
      </details>
    `);

    addRow("Cost of Production", rec.COP, `
      <div>COP = Prime Cost + Factory Overheads</div>
      <div>= ${fmt(rec.prime)} + ${fmt(rec.FOH)} = ${fmt(rec.COP)}</div>
    `);

    t.innerHTML = `
      <thead><tr><th>Particulars</th><th>Amount</th></tr></thead>
      <tbody>${rows.join("")}</tbody>
    `;

    [...t.querySelectorAll("tr.clickable")].forEach(tr => {
      tr.addEventListener("click", () => {
        const id = tr.getAttribute("data-work");
        const workRow = $(id);
        const caret = tr.querySelector(".caret");
        const open = !workRow.classList.contains("hidden");
        workRow.classList.toggle("hidden");
        caret.textContent = open ? "▶" : "▼";
      });
    });
  }

  // ---------- End States ----------
  function endGameOver(reason) {
    $("revealBox").classList.add("hidden");
    $("gameOverBox").classList.remove("hidden");

    $("gameOverText").innerHTML = `
      <p class="danger"><b>Reason:</b> ${escapeHtml(reason)}</p>
      <p class="muted mono">
        Snapshot: Total COP ${fmt(state.totalCOP)} | Scrap ${fmt(state.scrapRate*100)}% | Quality risk ${state.qualityRisk}
      </p>
    `;

    $("retryBtn").onclick = () => { resetState(); showPreEpisode(); };
    updateRightPanel();
  }

  function endSeasonComplete() {
    $("revealBox").classList.add("hidden");
    $("seasonCompleteBox").classList.remove("hidden");

    const your = state.totalCOP;
    const best = BEST_COP;
    const dev = ((your - best) / best) * 100;

    $("seasonSummary").innerHTML = `
      <p class="mono">
        <b>Total COP (Ep2–Ep8):</b> ${fmt(state.totalCOP)}<br/>
        <b>Final scrap rate:</b> ${fmt(state.scrapRate*100)}%<br/>
        <b>Final quality risk:</b> ${state.qualityRisk}
      </p>
      <p class="muted small">Video deep dive appears only here (not on Game Over).</p>
    `;

    $("yourCop").textContent = fmt(your);
    $("bestCop").textContent = fmt(best);
    $("deviation").textContent = `${dev >= 0 ? "+" : ""}${fmt(dev)}%`;
    $("endStatus").innerHTML = `Targets met: Yes (all episodes)<br/>Scrap: ${fmt(state.scrapRate*100)}%<br/>Quality risk: ${state.qualityRisk}`;

    $("videoBtn").onclick = () => alert("Video deep dive (placeholder). Add your embed/link here later.");
    $("playAgainBtn").onclick = () => { resetState(); showPreEpisode(); };
    $("shareBtn").onclick = () => shareResult(your, dev);

    updateRightPanel();
  }

  // ---------- Share ----------
  function shareText(your, dev) {
    return `I finished Manufacturing Adventure (Season 1)!\n` +
      `Total COP: ${fmt(your)} | Scrap: ${fmt(state.scrapRate*100)}% | Quality risk: ${state.qualityRisk}\n` +
      `Best COP is ${fmt(BEST_COP)} (I’m ${dev >= 0 ? "+" : ""}${fmt(dev)}%). Can you beat me?`;
  }

  async function shareResult(your, dev) {
    const text = shareText(your, dev);
    const url = buildShareUrl();

    if (navigator.share) {
      try {
        await navigator.share({
          title: "Manufacturing Adventure — Season 1",
          text: text,
          url
        });
        toast("Shared!");
        return;
      } catch (e) {}
    }

    const clip = `${text}\n${url}`;
    try {
      await navigator.clipboard.writeText(clip);
      toast("Copied share text!");
    } catch (e) {
      window.prompt("Copy your result:", clip);
    }
  }

  // ---------- Helpers ----------
  function escapeHtml(s) {
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  // ---------- Wiring / Boot ----------
  $("startSeasonBtn").onclick = () => showEpisodeScreen();

  resetState();
  showPreEpisode();

})();
</script>
